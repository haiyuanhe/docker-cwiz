meta section
meta.meta=---\n\
title: 系统巡检报告\n\
author: %s\n\
date: %s\n\
...\n

general section
general.overview=本次巡检周期自%s起至%s止，在本周期内，共监控**%s**台主机和**%s**项服务。\n
general.health=本巡检周期内系统**%s%%**的时间处于优秀状态；**%s%%**的时间处于良好状态；**%s%%**的时间处于中等状态。系统整体健康状况变化如下图所示：\n![](%s)\n
general.alert=本巡检周期内系统共产生**%s**个告警，其中**%s**个严重告警，**%s**个一般告警；有**%s**个告警被解决，有**%s**个尚未解决。\n
general.noalert=本巡检周期内系统没有产生任何告警。\n

general.host=总CPU核数：**%s**个；总内存容量：**%s**MB；总存储容量：**%s**GB。\n
general.service=系统中监控的服务共有**%s**项，其中正在运行**%s**项，警告**%s**项，严重**%s**项，没有运行**%s**项。

general.oncall=本巡检周期内共有**%s**名人员参与值班，人员信息如下表所示：\n\
\n\
+------------------------------+----------------------------------------+------------------------------+ \n\
| 姓名                         | 邮箱                                   | 电话                          | \n\
+==============================+========================================+==============================+ \n

general.oncall.row=|%s|%s|%s| \n\
+------------------------------+----------------------------------------+------------------------------+ \n

general.nooncall=本巡检周期内没有设置值班人员。\n

alert section
alert.overview=本次巡检周期内共产生**%s**个告警，其中**%s**个严重告警，**%s**个一般告警。系统实时总告警数变化如下图所示。请注意下图中的每个数据点的粒度是4个小时，它表示每4个小时中任意时刻报警状态为Critical/Warning的最大数量。比如报警规则A发生在1：00-6：00am，报警规则B发生在5：00-7：00am，那么0：00-4：00am的值是1，4：00-8：00am的值是2。\n![](%s)\n
alert.openalerts=系统中尚有**%s**个告警没有被解决，如下表所示：\n\
\n\
+----------------------------------------+------------------------------+------------------------------+ \n\
| 告警名称                               | 主机名                       | 报警时间                       | \n\
+========================================+==============================+==============================+ \n

alert.openalerts.row=|%s|%s|%s| \n\
+----------------------------------------+------------------------------+------------------------------+ \n

alert.topalerts=按告警规则区分，告警触发次数及分布见下图：\n\
![](%s)\n

alert.metrics=按所属类型区分，告警触发次数及分布如下：\n\
![](%s)\n

alert.lifespan=以告警处理时间来看，最长的告警处理时间为**%s**分钟，最短的告警处理时间为**%s**分钟，平均处理时间则为**%s**分钟。\n\
处理时间最长的告警如下表所示：\n\
\n\
+----------------------------------------+--------------------+--------------------------+--------------------------+----------+ \n\
| 告警名称                               | 告警主机           | 告警时间                 | 处理时间                 | 处理时长（分钟）    | \n\
+========================================+====================+==========================+==========================+==========+ \n

alert.lifespan.row=|%s|%s|%s|%s|%s| \n\
+----------------------------------------+--------------------+--------------------------+--------------------------+----------+ \n

alert.lifespan.noalert=以告警处理时间来看，所有告警处理时间均不超过1分钟。

host section
host.cpuusage=![](%s)\n
host.memusage=![](%s)\n
host.iousage=![](%s)\n
host.dfusage=![](%s)\n
host.noohostoverview=系统内暂无正在监控的主机。
host.overview=系统内正在监控的主机有**%s**台，其资源使用详情如下表：\n\
\n\
+-----------------+-----------------+------------------------------+------------------------------+------------------------------+ \n\
| 主机名称        | IP              | CPU使用率（平均值/最大值）   | MEM使用率（平均值/最大值）   | Disk使用率（平均值/最大值）   | \n\
+=================+=================+==============================+==============================+==============================+ \n

host.overview.row=|%s|%s|%s|%s|%s| \n\
+-----------------+-----------------+------------------------------+------------------------------+------------------------------+ \n

service section
service.overview=当前系统中共监控服务**%s**项，每项服务实例数如下表所示：\n\
\n\
+----------------------------------------+------------------------------+------------------------------+ \n\
| 服务名称                               | 实例数                       | 开始监控时间                   | \n\
+========================================+==============================+==============================+ \n

service.row=|%s|%s|%s| \n\
+----------------------------------------+------------------------------+------------------------------+ \n
service.overview.noservice=当前系统中没有监控服务，请在管理界面中配置监控服务。

hbase section
hbase.normal=HBase本周总体运行正常，没有发生过Server Offline的情况，其中RegionServer个数为%s，在线Region Server也为%s。\n
hbase.problem=HBase本周有异常情况发生，出现过Server Offline的情况，其中RegionServer的服务数量情况如下图所示:\n\![](%s)\n
hbase.regionsCount=每个RegionServer的Region数量如下图所示:\n\
![](%s)\n
hbase.storeFileCount=每个RegionServer的StoreFile数量如下图所示:\n\
![](%s)\n
hbase.storeFileSize=每个RegionServer的StoreFile大小如下图所示:\n\
![](%s)\n
hbase.memoryInfo=每个RegionServer的内存分配情况(已使用堆内存 Used Heap，最大堆内存Max Heap，Memstore Size)如下图所示:\n![](%s)\n![](%s)\n
hbase.requestInfo=每个RegionServer的读写情况及平均每分钟请求数如下图所示:\n\![](%s)\n![](%s)\n![](%s)\n

elasticsearch section
es.prev=本周Elasticsearch集群整体运行正常。
es.statusAlert=但是健康状态出现过%s的情况。
es.statusCurrentGreen=当前集群健康状态为绿色，所有的主分片和副本分片都已分配,而且都是可用的。\n
es.statusCurrentRedOrYellowPre=当前集群健康状态为%s,
es.statusCurrentReason=由于%s的原因，
es.statusCurrentRedSuffix=导致数据的主分片未分配，会导致索引文档失败，并且只能检索部分数据。建议检查是否数据节点都不可用，如果有可用的数据节点，将节点上未分配的主分片重新分配。\n
es.healthNodes=节点%s,
es.indexs=索引%s的
es.statusCurrentYellowSuffix=副本分片未分配。当前状态集群能够正常运行，但是如果状态长时间黄色，可能会导致恢复数据问题，建议将节点上未分配副本分片重新分配。\n
es.statusChart=集群健康状态如下图所示：\n\
![](%s)\n
es.cpuper=当前，节点%s的CPU使用率超过%s，高位运行，可能是由于节点检索或者索引的数据量比较大导致。建议可以增加节点来降低负载。\n
es.cpuperChart=各节点的CPU使用率如下图所示：\n\
![](%s)\n
es.searchShareCountsChart=各节点的检索分片数量如下图所示：\n\
![](%s)\n
es.indexCountsChart=各节点的索引数据次数如下图所示：\n\
![](%s)\n
es.memper=当前，节点%s的内存使用率持续超过%s，高位运行，可能是由于节点索引的数据量过多，或者分片数量过多导致，如果长时间高位运行可能会导致内存溢出。建议可以通过关闭不用的索引，或者增加节点内存来缓解节点压力。\n
es.memperChart=各节点的内存使用率如下图所示：\n\
![](%s)\n
es.yongGCCountsChart=各节点的新生代GC总次数如下图所示：\n\
![](%s)\n
es.yongGCTimeChart=各节点的新生代GC消耗时间如下图所示：\n\
![](%s)\n
es.oldGCCountsChart=各节点的老年代GC总次数如下图所示：\n\
![](%s)\n
es.oldGCTimeChart=各节点的老年代GC消耗时间如下图所示：\n\
![](%s)\n
es.diskper=当前，节点%s的磁盘剩余容量小于%sG，可能是由于节点的索引的文档数据量过多的原因，会导致节点失效，不能够索引数据。建议可以通过删除特定的，或者不使用的索引以保证磁盘的可用性，或者增加磁盘容量，或者增加节点。\n
es.diskperChart=各节点的磁盘剩余容量如下图所示：\n\
![](%s)\n
es.searchAvgTime=当前，节点%s的平均查询延迟时间超过%毫秒，高位运行，可能是由于存在的慢查询的原因，也有可能是节点的分片数量过大导致查询变慢。建议查找是否有慢查询，进行优化查询，或者设置更少的分片数量。\n
es.searchAvgTimeChart=各节点的平均查询延迟时间如下图所示：\n\
![](%s)\n
es.fetchAvgTime=当前，节点%s的提取数据平均延迟时间超过%s毫秒，高位运行，可能是由于节点的磁盘性能不好的原因，也有可能是节点提取数据的请求数量过多导致提取数据变慢。建议替换磁盘性能不好的节点，或者增加节点来分担查询提取数据的压力。\n
es.fetchAvgTimeChart=各节点的提取数据平均延迟时间如下图所示：\n\
![](%s)\n
es.indexAvgTime=当前，节点%s的索引数据平均延迟时间超过%s毫秒，高位运行，可能是由于节点一次性的索引了太多的文档的原因导致索引文档变慢。建议通过减少刷新频率来优化，或者索引设置暂时的禁用刷新，等索引完文档以后再设置成原来的刷新频率。\n
es.indexAvgTimeChart=各节点的索引数据平均延迟率如下图所示：\n\
![](%s)\n
es.jvmHeapPer=当前，节点%s的JVM堆使用率持续超过%s，高位运行，可能是由于设置分配给JVM堆的内存过小，或者节点的查询和索引压力过大导致内存垃圾的收集已经跟不上内存垃圾产生的速度。会导致内存溢出。建议通过设置加大分配JVM堆的的内存空间，但是一般不要超过内存的一半或者32G，也可以通过增加节点来分散各个节点的压力。\n
es.jvmHeapPerChart=各节点的JVM堆使用率如下图所示：\n\
![](%s)\n
es.sharesCounts=当前，节点%s的总分片数量超过%s个，节点的分片数量过多，会导致节点查询速率变慢。建议通过设置减小新建索引时创建分片的个数，或者增加节点来控制节点的分片数量，。\n
es.sharesCountsChart=各节点的总分片数量如下图所示：\n\
![](%s)\n
es.nodeCounts=本周最大数据节点数量%s个，当前节点数量%s个。
es.nodeCountsReason=可能是节点发生故障，或者人为关闭节点。如果数据不变的情况下，节点数减少可能会导致集群的检索速度变慢。建议如果数据量预期减少，可以酌情减少节点数，如果数据量不变或者增加的情况下，尽可能保证节点数量不会减少。\n
es.nodeCountsChart=集群的节点数量如下图所示：\n\
![](%s)\n

sqlserver section
sqlserver.diskFreeSummary=当前，服务器剩余空闲磁盘空间共计%sGB,注意已经在设定的%sGB警戒线以下。\n
sqlserver.memFreeSummary=当前，服务器剩余空闲内存空间共计%sGB,注意已经在设定的%sGB警戒线以下。\n
sqlserver.cacheRatioSummary=当前，服务器的平均缓存命中率%s，低于设定的告警值%s，缓存命中率过低会影响查询的效率，可以考虑增加内存提高缓存命中率。\n
sqlserver.deadlockSummary=本周共产生%s次死锁。死锁会导致系统功能不响应或者执行异常。\n
sqlserver.slowQuertySummary=本周共产生%s次慢查询。当慢查询的过多，会影响系统的性能，降低系统效率，增加系统的响应时间，建议分析解决对应的慢查询。\n
sqlserver.uselessIndexsSummary=当前，服务器存在%s个无用的索引,具体参见系统索引信息。\n
sqlserver.batchCompileSummary=当前，服务器批处理编译数量比为%s，低于设定的告警值%s,过多的编译执行计划比较耗时，且耗费资源。\n
sqlserver.compileRecompileSummary=当前，服务器编译重编译数量比为%s，低于设定的告警值%s,过多编译执行计划的失败导致重新编译会比较耗时，且耗费资源。\n
sqlserver.memChart=本周服务器的内存使用情况如下图所示：\n\
![](%s)\n
sqlserver.deadlockChart=本周服务器产生死锁信息如下图所示。过多的产生死锁会导致系统部分功能不响应，或者执行异常，建议分析产生死锁原因，尽快解决。\n
sqlserver.slowQueryCount=本周服务器慢查询平均执行时间%s秒，平均最大执行时时间%s秒。当慢查询的过多，会影响系统的性能，降低系统效率，增加系统的响应时间，建议分析解决对应的慢查询。\n
sqlserver.slowQueryCountChart=本周服务器产生慢查询次数如下图所示：\n\
![](%s)\n
sqlserver.slowQueryDetailChart=慢查询的详细信息如下：\n
sqlserver.uselessIndex=服务器的无用索引详情如下图所示：\n
sqlserver.lackIndex=服务器的索引缺失详情如下图所示：\n
sqlserver.maxAndMinCacheRatio=本周服务器的最大平均缓存命中率是%s，最小平均缓存命中率是%s。缓存命中率越高，说明查询的效率越高，如果缓存命中率低于%s，可以考虑增加内存或者改变缓存更新策略提高缓存命中率。\n
sqlserver.cacheRatioChart=本周服务器的平均缓存命中率如下图所示：\n\
![](%s)\n
sqlserver.maxAndMinBatchCompileRatio=本周服务器的批处理编译最大数量比%s，最小数量比%s。批处理编译数量比是衡量服务器单位时间内批处理和编译执行计划的数量之比，由于编译执行计划比较耗时，且耗费资源，所以数量比越大越好，尽量保持在%s倍以上。\n
sqlserver.batchCompileRatioChart=本周服务器的批处理编译数量比如下图所示：\n\
![](%s)\n
sqlserver.maxAndMinCompileRecompileRatio=本周服务器的编译重编译最大数量比%s，最小数量比%s。编译重编译数量比是衡量服务器单位时间内编译执行计划和由于编译失败导致重新编译的数量之比，由于编译执行计划比较耗时，且耗费资源，所以本指标值越大越好，尽量保持在%s倍以上。\n
sqlserver.compileRecompileRatioChart=本周服务器的编译重编译数量比如下图所示：\n\
![](%s)\n
sqlserver.batchRequests=批处理请求数直接体现的是服务器的吞吐量，每秒的批处理请求数越大，说明服务器的吞吐量越大。\n\
本周的批处理请求数如下图所示:\n\
![](%s)\n
sqlserver.connectionCounts=连接数直接体现的是服务器一段时间的连接压力，如果在一段时间内连接数大幅增加，需要注意控制连接数量，防止服务器连接数超过最大值。\n\
本周的连接数如下图所示:\n\
![](%s)\n
sqlserver.queryPerformance=查询响应时间直接体现的是服务器的查询效率，响应时间越小，说明服务器的查询效率越高。\n\
本周的查询响应时间如下图所示:\n\
![](%s)\n
sqlserver.pageLife=页停留缓冲区平均时间体现的是已经被引用的页面停留在缓冲区中的时间，时间越长，意味着CPU为了执行页面切换的时间越长，如果时间很短，说明CPU短时间内频繁的切换页面，影响服务器的效率。\n\
本周的页停留缓冲区平均时间如下图所示:\n\
![](%s)\n
sqlserver.checkpointsPage=检查点刷新脏页数量体现的是当数据页面发生变化时，该页面即被标记为脏页面，检查点到达时会将脏页面回写到物理磁盘中进行保存，即页面的提交。这个值越大，很可能意味着数据库对查询出的数据进行数据更新的操作比较频繁，导致缓冲区中保存的查询的数据页面被修改\n\
本周的检查点刷新脏页数量如下图所示:\n\
![](%s)\n
sqlserver.waitLock=等待锁请求数体现的是服务器中等待操作数据锁的请求个数，指标值越小越好，最好为0，因为大量的锁等待会拖慢系统，使得系统响应时间变大。\n\
本周的等待锁请求数如下图所示:\n\
![](%s)\n
sqlserver.capacityPlan=数据库的运⾏依赖计算、存储、⽹络等多种资源，通过对各种资源的使⽤情况分析，对资源进⾏合理的规划配置，是数据库稳定运⾏的必要条件，本次巡检时间窗⼝内，CPU,内存和磁盘的使⽤概况及扩容建议如下(扩容建议标准:当资源的平均使⽤率超过80%,最⼤使⽤率超过90%,下同)：\n

mysql section
mysql.state.summary=当前系统中共有%s个mysql实例,%s个实例处于启动状态，%s个实例处于关闭状态,%s个实例当前状态未知.(未知状态:探针未启动无法收集最新状态),当前实例状态如下: \n

mysql.alert=本次巡检周期内部署mysql服务器报警总览如下: \n

mysql.event=本次巡检周期内mysql发生的时间总览如下(目前支持启动和关闭两种事件): \n

mysql.important.metric=本章节我们将从数据库的连接数,流量以及语句执行三个方面进行详细检查,为了显示清晰,我们将巡检时间区间分为七个时间点进行统计异常点,若统计时段内数据过多,我们建议优先多指标同时发生异常的时间段以及异常点发生最多的时间段.\n

mysql.connect=连接数是最直接反应数据库性能好坏的关键指标,连接数的异常数据操作阻塞,导致后续DML操作等待,所以连接数的指标正常与否至关重要,在本次巡检周期内,连接数相关各项指标概览如下:\n

mysql.open.connect=- **打开的连接数**:当该指标发生异常时,特别是过高且接近最大限制很有可能引发数据库连接阻塞等严重问题,本次巡检周期内异常统计如下:\n\
![](%s)\n
mysql.open.connect.no=- **打开的连接数**:本次巡检周期内该指标未发现异常,但是当该指标发生异常时,特别是过高且接近最大限制很有可能引发数据库连接阻塞等严重问题.\n\

mysql.running.connect=- **运行的连接数**:当该指标发生异常时,表示当前活跃的连接异常,可能有不稳定业务发生,本次巡检周期内异常统计如下:\n\
![](%s)\n
mysql.running.connect.no=- **运行的连接数**:本次巡检周期内该指标未发现异常,但是当该指标发生异常时,表示当前活跃的连接异常,可能有不稳定业务发生.\n\

mysql.aborted.connect=- **尝试连接到数据库失败的次数**:当该指标发生异常,很有可能当前数据库出现一些错误导致无法连接,需要特别注意,本次巡检周期内异常统计如下:\n\
![](%s)\n
mysql.aborted.connect.no=- **尝试连接到数据库失败的次数**:本次巡检周期内该指标未发现异常,但是当该指标发生异常,很有可能当前数据库出现一些错误导致无法连接,需要特别注意.\n\

mysql.error.internal.connect=- **因数据库内部错误而被拒绝的连接数**:当指标发生异常,很有可能导致数据库无法创建新的连接,可能反映为内存不足或服务器无法启动新线程,需要特别注意,本次巡检周期内异常统计如下:\n\
![](%s)\n
mysql.error.internal.connect.no=- **因数据库内部错误而被拒绝的连接数**:本次巡检周期内该指标未发现异常,但是当指标发生异常,很有可能导致数据库无法创建新的连接,可能反映为内存不足或服务器无法启动新线程,需要特别注意.\n\

mysql.error.max.connect=- **因最大连接数限制而被拒绝的连接数**:当该指标发生异常,是由于当前已开启的连接数达到数据库设置的最大数限制导致新的数据库连接无法建立,我们通常采取增加数据库连接数来使数据库正常运行,本次巡检周期内异常统计如下:\n\
![](%s)\n
mysql.error.max.connect.no=- **因最大连接数限制而被拒绝的连接数**:本次巡检周期内该指标未发现异常,但是当该指标发生异常,一般是由于当前已开启的连接数达到数据库设置的最大数限制导致新的数据库连接无法建立,我们通常采取增加数据库连接数来使数据库正常运行,本次巡检周期内异常统计如下:\n\

mysql.throughput.performance=本章节我们将从查询流量和事件响应时间两个方面进行详细检查,为了显示清晰,我们将巡检时间区间分为七个时间点进行统计异常点,若统计时段内数据过多,我们建议优先多指标同时发生异常的时间段以及异常点发生最多的时间段.\n

mysql.throughput=吞吐量是我们常见的一个软件性能指标,对于软件系统来说,"吞"进去的是请求,"吐"出来的是结果,而吞吐量反映的就是软件系统的"饭量",也就是系统的处理能力,具体说来,就是指系统在每单位时间内能处理多少个事务/请求/单位数据等.本章节我们将从数据流量吞吐和SQL语句的吞吐两个方面来进行分析.\n

mysql.throughput.net=网络吞吐量是单位时间内在网络上传输的数据流量,它是最直观反应当前数据库使用的指标之一,同时也能捕获一些异常的流入流出,本次巡检周期内网络流量概览如下:\n

mysql.throughput.sql=SQL吞吐量是单位时间内执行的语句数,它是最直观反应当前数据库使用的指标之一,同时也能捕获一些异常的流入流出,本次巡检周期内SQL语句执行概览如下:\n

mysql.throughput.net.bytesSent=- **平均每秒流出流量**:当该指标发生异常表示流出流量出现有违历史周期的激增或者激减,重点关注是否有异常的调用出现(定时job/恶意攻击),本次巡检周期内其趋势统计如下所示:\n\
![](%s)\n
mysql.throughput.net.bytesSent.anomaly.no=**本次巡检周期内无异常发生.**\n
mysql.throughput.net.bytesSent.anomaly=**本次巡检周期内异常点统计如下:**\n\
![](%s)\n

mysql.throughput.net.bytesReceive=- **平均每秒流入流量**:当该指标发生异常表示流入流量出现有违历史周期的激增或者激减,重点关注是否有异常的调用出现(定时job/恶意攻击),本次巡检周期内其趋势统计如下所示:\n\
![](%s)\n
mysql.throughput.net.bytesReceive.anomaly.no=**本次巡检周期内无异常发生.**\n
mysql.throughput.net.bytesReceive.anomaly=**本次巡检周期内异常点统计如下:**\n\
![](%s)\n

mysql.throughput.sql.select=- **平均每秒执行SELECT数**:平均每秒执行SELECT次数,本次巡检周期内其趋势统计如下所示:\n\
![](%s)\n
mysql.throughput.sql.select.anomaly.no=**本次巡检周期内无异常发生.**\n
mysql.throughput.sql.select.anomaly=**本次巡检周期内异常点统计如下:**\n\
![](%s)\n

mysql.throughput.sql.insert=- **平均每秒执行SELECT数**:平均每秒执行INSERT次数,本次巡检周期内其趋势统计如下所示:\n\
![](%s)\n
mysql.throughput.sql.insert.anomaly.no=**本次巡检周期内无异常发生.**\n
mysql.throughput.sql.insert.anomaly=**本次巡检周期内异常点统计如下:**\n\
![](%s)\n

mysql.throughput.sql.update=- **平均每秒执行SELECT数**:平均每秒执行UPDATE次数,本次巡检周期内其趋势统计如下所示:\n\
![](%s)\n
mysql.throughput.sql.update.anomaly.no=**本次巡检周期内无异常发生.**\n
mysql.throughput.sql.update.anomaly=**本次巡检周期内异常点统计如下:**\n\
![](%s)\n

mysql.throughput.sql.delete=- **平均每秒执行SELECT数**:平均每秒执行DELETE次数,本次巡检周期内其趋势统计如下所示:\n\
![](%s)\n
mysql.throughput.sql.delete.anomaly.no=**本次巡检周期内无异常发生.**\n
mysql.throughput.sql.delete.anomaly=**本次巡检周期内异常点统计如下:**\n\
![](%s)\n

mysql.run.time=语句执行的平均耗费的时间直接影响用户的请求能否迅速响应,若平均响应时延较长,我们应该关注是否有慢查询或者死锁发生,本次巡检周期内各个数据库平均响应时延概览如下:\n
mysql.run.time.anomaly.no=**本次巡检周期内无异常发生.**\n
mysql.run.time.anomaly=**本次巡检周期内异常点统计如下:**\n\
![](%s)\n

mysql.innodb=Innodb维护了一个缓存区域叫做Buffer Pool，用来缓存数据和索引在内存中。Buffer Pool可以用来加速数据的读写，如果Buffer Pool越大，那么Mysql就越像一个内存数据库，所以了解Buffer Pool的配置可以提高Buffer Pool的性能。如果一个数据页在内存中修改了，但是还没有刷新到磁盘。这个数据页就称作脏页,某一时间我们将内存中的脏页数据刷新到磁盘上,这个时间点我们称之为checkpoint,它能够帮助我们在数据库出现不可预知问题时恢复数据.\n

mysql.innodb.buffer.req=- **已完成的逻辑读请求数**:逻辑读请求是指我们直接从内存中读取的请求数,我们这里也可以看作Innodb所有读操作的次数,这个指标一般在一个周期内基本是比较稳定的,本次巡检周期内其趋势统计如下所示:\n\
![](%s)\n
mysql.innodb.buffer.req.anomaly.no=**本次巡检周期内无异常发生.**\n
mysql.innodb.buffer.req.anomaly=**本次巡检周期内异常点统计如下:**\n\
![](%s)\n

mysql.innodb.buffer.read=- **缓冲池中无法满足的读请求数**:缓冲池无法满足查询需求,只能够从磁盘中获取请求结果,我们都知道从内存获取数据比从磁盘读取是要快多个数量级的,所以当该指标上升时,读取的性能会收到很大的影响,本次巡检周期内其趋势统计如下所示:\n\
![](%s)\n
mysql.innodb.buffer.read.anomaly.no=**本次巡检周期内无异常发生.**\n
mysql.innodb.buffer.read.anomaly=**本次巡检周期内异常点统计如下:**\n\
![](%s)\n

mysql.innodb.buffer.page.free=- **缓存池中空白页大小**:当空白页越小也代表着当前缓冲池的利用率越高,但是当空白页越来越小时,我应该考虑增加我们的缓存大小,避免因为可用缓存的减少而影响到当前数据库的查询性能,本次巡检周期内其趋势统计如下所示:\n\
![](%s)\n
mysql.innodb.buffer.page.free.anomaly.no=**本次巡检周期内无异常发生.**\n
mysql.innodb.buffer.page.free.anomaly=**本次巡检周期内异常点统计如下**:\n\
![](%s)\n

mysql.innodb.buffer.page.dirty=- **缓存中脏页大小**:如果一个数据页在内存中修改了，但是还没有刷新到磁盘。这个数据页就称作脏页。脏页的每一次刷新,我们都会在redo log中记录一个checkpoint,checkpoint的作用在于当系统出现故障时,我们可以根据这个时间节点恢复数据库数据,这也是我们数据库运维中非常重要的一环,本次巡检周期内其趋势统计如下所示:\n\
![](%s)\n
mysql.innodb.buffer.page.dirty.anomaly.no=**本次巡检周期内无异常发生**.\n
mysql.innodb.buffer.page.dirty.anomaly=**本次巡检周期内异常点统计如下:**\n\
![](%s)\n

mysql.lock=数据库锁出现的原因是为了处理并发问题，因为数据库是一个多用户共享的资源，当出现并发的时候，就会导致出现各种各样奇怪的问题，就像程序代码一样，出现多线程并发的时候，如果不做特殊控制的话，就会出现意外的事情，比如“脏“数据、修改丢失等问题。所以数据库并发需要使用事务来控制，事务并发问题需要数据库锁来控制，所以数据库锁是跟并发控制和事务联系在一起的。但是如果操作不能立即获得对应的锁就会导致操作阻塞甚至死锁.\n

mysql.lock.table.wait=- **平均每秒不能立刻获得表锁的次数**:如果该值较高，并且有性能问题，当前数据库的操很有可能已经作受到阻塞,需要首先优化查询，然后拆分表或使用复制来进行优化.\n\
![](%s)\n
mysql.lock.table.wait.anomaly.no=**本次巡检周期内无异常发生**.\n
mysql.lock.table.wait.anomaly=**本次巡检周期内异常点统计如下:**\n\
![](%s)\n

mysql.lock.row.wait=- **当前正在等待锁的数量**:如果该值较高，并且有性能问题,当前数据库的操很有可能已经作受到阻塞,我们可以扩大缓冲池的大小(buffer pool)来优化解决这个问题.\n\
![](%s)\n
mysql.lock.row.wait.anomaly.no=**本次巡检周期内无异常发生**.\n
mysql.lock.row.wait.anomaly=**本次巡检周期内异常点统计如下:**\n\
![](%s)\n

mysql.index=索引用于快速找出在某个列中有一特定值的行，不使用索引，MySQL必须从第一条记录开始读完整个表，直到找出相关的行，表越大，查询数据所花费的时间就越多，如果表中查询的列有一个索引，MySQL能够快速到达一个位置去搜索数据文件，而不必查看所有数据，那么将会节省很大一部分时间,所以索引的构建对我们数据库的使用非常重要,优秀的索引构造能够起到事半功倍的效果.我们将从索引缺失,索引字段重复,索引是否使用三个方面对当前索引的构建作一个检查.\n

mysql.index.miss=- **索引缺失**:当前数据库中未建立索引的库表统计如下:\n
mysql.index.duplicate=- **索引字段重复**:当前数据库中数据表字段重复建立索引的统计如下:\n
mysql.index.unused=- **索引未使用**:当前数据库中已建立索引但是从未使用过的索引统计如下:\n

mysql.capacity1=数据库的运行依赖计算、存储、网络等多种资源，通过对各种资源的使用情况分析，对资源进行合理的规划配置，是数据库稳定运行的必要条件，本次巡检时间窗口内，CPU和内存的使用概况及扩容建议如下(扩容建议标准:当资源的平均使用率超过80%,最大使用率超过90%,下同)：\n

mysql.capacity2=本章节我们将对mysql的重要使用指标进行一个检测,检测的部分包括对应指标的最大值/平均值以及指标的异常检测,若密集出现异常请关注.\n

mysql.critical.summary=我们对当前系统中的mysql实例进行扫描检查是否出现影响实例正常运行的严重问题(目前支持:慢查询/死锁/索引检测).\n\

mysql.slow.overview=慢查询：我们指那些执行时间超过某个阈值的SQL语句。当数据库出现慢查询，对于不同的存储引擎，危害分为以下两种情况：\n1. 当表为MyiSAM表，出现慢查询，Select操作不会被阻塞，但是对该表的DML和DDL操作均会被阻塞；\n2. 当表为Innodb表，出现慢查询，Select和DML不会被阻塞，但是当所属数据库发生DDL操作则会导致整个数据库进入等待；\n在本次巡检时间窗口内，各个实例的慢查询聚类（相似语句做了合并统计）统计如下：\n

mysql.deadlock.overview=死锁是指两个或两个以上的事务在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。当发生死锁时，会造成数据库其他事务产生大量阻塞，阻塞不仅会拖慢执行的速率，而且当大量阻塞时会导致大量机器资源被占用最后拖垮服务器。\n\
在本次巡检时间窗口内，我们通过监控错误日志中死锁日志，死锁事件统计如下：\n

mysql.deadlock.overview.row=|%s|%s| \n\
+-----------------+-----------------+ \n\

mysql.primary.index.miss.summary=由于MySQL默认存储引擎InnoDB（MySQL 5.6版本以上）使用的是聚簇索引表设计，这就要求所有的表必须包含一个主键，所有的数据记录按照主键次序构建B+树。如果用户在创建表时显式指定主键，则数据库会使用用户指定的主键构建B+树，但是如果用户没有显式指定主键，同时也没有创建任何唯一键索引，InnoDB为了确保每张表至少包含一个主键，则默认会为用户生成一个“隐含主键”，该主键对用户不可见，甚至对于MySQL Server层的binlog也不可见。binlog是连接MySQL主从复制节点的纽带，所有主节点的更新都是通过binlog传递给从节点的，一旦binlog中没有更新记录的主键ID，这就会导致基于Row格式的binlog在从节点执行时，无法唯一确定一条记录，只能通过全表扫描来进行匹配，大幅降低了从机的执行效率，造成复制延迟。如果是高可用故障切换的从节点，会导致切换的时间大幅增加，甚至会导致高可用机制失效。如果是实现读写分离的只读从节点，则会导致应用读到的数据可能是很久以前的旧数据。所以我们建议使用InnoDB存储引擎的MySQL用户在创建表时，必须显式指定主键。/n/
截至报告生成时，各实例中未创建主键索引的表如下：\n\
\n\
+-----------------+-----------------+-----------------+ \n\
| 实例            | 数据库           | 数据表           | \n\
+=================+=================+=================+ \n

mysql.primary.index.miss.summary.row=|%s|%s|%s| \n\
+-----------------+-----------------+-----------------+ \n\

mysql.duplicate.index.summary=重复索引是指的在相同的列上按照相同的顺序创建的相同类型的索引，应该避免这样创建重复索引因为他会导致额外的性能开销。\n\
截至报告生成时，重复索引统计如下：\n\
\n\
+-----------------+-----------------+-----------------+-----------------+-----------------+ \n\
| 实例            | 数据库           | 数据表           | 索引           | 列              | \n\
+=================+=================+=================+=================+=================+ \n

mysql.duplicate.index.summary.row=|%s|%s|%s|%s|%s| \n\
+-----------------+-----------------+-----------------+-----------------+-----------------+ \n\

mysql.invalid.index.summary=当数据表建立的索引始终无法被查询使用，它就毫无用处且会增加数据库的额外开销。\n\
截至报告生成时，各实例无效索引统计如下：\n\
\n\
+-----------------+-----------------+-----------------+-----------------+ \n\
| 实例            | 数据库           | 数据表           |  索引           | \n\
+=================+=================+=================+=================+ \n

mysql.invalid.index.summary.row=|%s|%s|%s|%s| \n\
+-----------------+-----------------+-----------------+-----------------+ \n\
